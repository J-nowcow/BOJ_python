"""
피보나치 수를 구하는 방법 중 가장 빠른 방법은 행렬을 계산하는 것이다.

[(Fn+1,Fn),(Fn,Fn-1)] * [(1,1),(1,0)]
= [(Fn+1 + Fn, Fn+1), (Fn + Fn-1, Fn)]
= [(Fn+2, Fn+1), (Fn+1, Fn)] 이다.
[(1,1),(1,0)] = [(F2, F1), (F1, F0)] 이므로
A = [(1,1),(1,0)] 일 때
Fn = A^n 의 (0,1) 번째 항이다.

따라서 n을 입력받아 2진수로 변환한 다음 제곱한 행렬들을 각각 구해서 다 곱해주면 된다.
이러면 O(logn) 시간에 피보나치 수를 계산할 수 있다.

주어진 n이 10^18이므로 이 방식으로 계산해주면 된다.
n을 10^6으로 나누어줘야 하는데, 그냥 덧셈 연산이 전부니까 1000000을 넘을 때마다 잘라주면 된다.
"""

n = int(input())

A = ((1,1),(1,0))
k = [A]

def x(X,Y):
    (a,b),(c,d) = X
    (e,f),(g,h) = Y
    return (((a*e+b*g)%10**6, (a*f+b*h)%10**6),((c*e+d*g)%10**6, (c*f+d*h)%10**6))

while 2 ** len(k) <= n:
    k.append(x(k[-1],k[-1]))

ans = ((1,0),(0,1))
pos = 0
while n:
    if n%2: ans = x(ans,k[pos])
    n >>= 1
    pos += 1

print(ans[0][1])
